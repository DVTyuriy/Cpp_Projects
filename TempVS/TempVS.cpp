#include <iostream>
#include <string>
#include <cstring>
#include <cmath>

#include <array>
#include <algorithm>

using namespace std;

void divide(float a, float b) {
    if (b == 0) throw 100; //если ошибка выбрасывает любое число как код ошибки
    else cout << (a / b);
}


int main()
{   //print list questions to the screen
        //setlocale(LC_ALL, "UKRAINIAN");
        //setlocale(LC_ALL, "RU");

        try {
            divide(5.2f, 0.0f);
        }
        catch (int err) {
            if (err == 100) cout << "Ошибка при делении на 0" << endl;
        }

        string str1 = "Hello";
        string str2 = "World";

        str1.append(str2);
        str1.pop_back(); //удаляет последний символ
        str1.push_back('!'); //добавляет последний символ
        str1.resize(5); //изменяет длину строки
        cout << str1 << " - " << str1.length(); //выдает длину строки

        cout << ceil(1.78f) << endl; //округляет к большему
        cout << floor(1.78f) << endl; //округляет к меньшему
        cout << round(1.78f) << endl; //математическое округление

        return 0;
}


// Шаблоны функций
#include <iostream>
#include <string>

using namespace std;
template <typename T, typename T2>
void print_arr(T* arr, int len) {
    for (T2 i = 0; i < len; i++)
        cout << *(arr + i) << " ";
    cout << endl;
}

int main()
{
    array <int, 10> test_array = { -1, 0, 1, -2, 2, -3, 3, 4, -4, 6 }; //так обявляем если нужен size, sort, перебор масива и т.д. 
    int arr1[] = { 5, 6 , 7 , 8, -2, 1 };
    print_arr<int, int>(arr1, 6);

    int n = sizeof(arr1) / sizeof(arr1[0]); //определяет длину масива. в общее количество в байтах  делится на длину первого масива в байтах 

    float arr2[] = { 0.5f, 0.78f, 1.98f };
    print_arr<float, int>(arr2, 3);

    for (auto& element : arr2) {
        std::cout << element << endl; //перебор все елементы масива
    }

}

#include <iostream>
#include <time.h>

using namespace std;

int main()
{
    srand(time(NULL));
    int random_number;
    random_number = rand();
    cout << random_number << " - псевдослучайное число\n";

    /*  
Налаштування диапазону для генератора
Если нужно генерировтаь числа от 0 до 10 или от 0 до 100?!то используем:
int a=rand()%25;
Если нужен диапазон другой, например от 11 до 16. Все просто. Число генерируемых от 0 до 5
(разница между 16 и 11), а затем «сдвинуть» результат на 11.
int a=rand()%6+11;
Аналогично можно получить другие диапазоны

    */
}

cout << fixed;
cout << setprecision(3) << kilometers << "км" << endl;

﻿/*std::array — це фіксований масив, який не конвертується у вказівник при передачі в функцію як параметр.
std::array визначається в заголовковому файлі array, всередині простору імен std.*/
#include <array>
#include <algorithm>
#include <iostream>
#include <windows.h>
void printLength(const std::array<int, 14>& myarray)
{
    std::cout << "Розмір масива: " << myarray.size() << std::endl;
}
int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    std::array<int, 14> myarray; // оголошуємо масив елементів типу int довжиною 14
    /*
    Подібно звичайним фіксованим масивам, довжина std::array має бути встановлена під час компіляції.
    std::array можна ініціалізувати за допомогою списку ініціалізаторів або уніфікованої ініціалізації:
    */
    std::array<int, 14> myarray1 = { 8, 6, 4, 1 };   // список ініціалізаторів
    std::array<int, 14> myarray2{ 8, 6, 4, 1 };   // uniform-ініціалізація
    //На відміну від стандартних фіксованих масивів, в std::array ви не можете пропустити(не вказувати) довжину масиву.
    //Також можна присвоювати значення існуючого масиву за допомогою списку ініціалізаторів :
    myarray = { 8, 6 }; // іншим елементам присвоєно нуль!
    myarray = { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 10, 11, 12, 13 }; // ок

    //myarray = { 0, 1, 3, 5, 7, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }; 
    // заборонено, занадто багато елементів в списку ініціалізаторів!
    //Доступ до значень масиву через оператор індексу здійснюється як зазвичай :
    myarray[12] = 720;
    std::cout << "Нове значення елемента масива: " << myarray[12];
    std::cout << std::endl;
    myarray[2] = 7;
    /*
    Так само, як і в стандартних фіксованих масивах, оператор індексу, тобто [] не виконує ніяких перевірок на діапазон.
    Якщо вказано некоректний індекс, то неявно відбудуться погані речі.
    Але std::array підтримує ще одну форму доступу до елементів масиву — функція at(), яка здійснює перевірку діапазону :
    */
    myarray.at(1) = 720; // елемент масиву під номером 1 - коректний, присвоюємо йому значення
    //myarray.at(18) = 150; // елемент масиву під номером 8 - некоректний, отримаємо помилку
    /*
    У прикладі, наведеному вище, виклик myarray.at(1) перевіряє, чи є елемент масиву під номером 1, і, оскільки він є,
    то є можливість змінити його. І ми присвоюємо йому значення 720. Проте, виклик myarray.at(18) не спрацьовує, оскільки елементу
    під номером 8 у масиві нема. Функція at() видає помилку, яка завершує роботу програми (генерується виняток типу std::out_of_range.
    Про винятки ми поговоримо трішки пізніше). Оскільки перевірка діапазону виконується, то функція at() працює повільніше(але безпечніше),
    ніж оператор[].
    */
    //За допомогою функції size() можна дізнатися довжину масиву :
    std::cout << "Розмір масива: " << myarray.size() << std::endl;
    /*
    Функція size() працюватиме, навіть якщо її викликати з іншої функції :
    */
    printLength(myarray);
    /*
    Зверніть увагу, Cтандартна бібліотека C++ використовує термін «розмір» для позначення довжини масиву — не плутайте це з результатами
    виконання оператора sizeof зі звичайним фіксованим масивом, коли повертається фактичний розмір масиву в пам’яті
    (розмір_елементу * довжина_масиву).
    Також зверніть увагу на те, що ми передаємо std::array по (константному) посиланню (&).Це робиться для того,
    щоб компілятор не виконував копіювання масиву при передачі в функцію.
    Правило : передавайте std::array в функцію по звичайному або константному посиланню.
    */


    // Оскільки довжина масиву завжди відома, то цикли foreach також можна використовувати з std::array :

    for (auto& element : myarray)
    {
        std::cout << element << ' ';
    }
    std::cout << std::endl;
    //Ви можете відсортувати std::array, використовуючи функцію std::sort(), яка є в заголовку algorithm :
    std::sort(myarray.begin(), myarray.end());   // сортування масиву за зростанням
    for (const auto& element : myarray)
    {
        std::cout << element << ' ';
    }
    std::cout << std::endl;
    std::sort(myarray.rbegin(), myarray.rend()); // сортування масиву за спаданням
    for (const auto& element : myarray)
    {
        std::cout << element << ' ';
    }
    std::cout << std::endl;
    return 0;
}

//Функція сортування використовує ітератори, які ми ще не розглядали.Про них ми поговоримо на відповідному уроці.

/*
Висновки
std::array — це чудова заміна стандартним фіксованим масивам.
Масиви, створені за допомогою std::array, ефективніші, використовують менше пам’яті. Єдиним недоліком std::array в порівнянні
зі стандартними фіксованими масивами є те, що потрібно явно вказувати довжину масиву (компілятор не обчислюватиме її за нас).
Але це порівняно незначні нюанси.Рекомендується використовувати std::array замість стандартних фіксованих масивів в будь-яких
нетривіальних завданнях.
*/